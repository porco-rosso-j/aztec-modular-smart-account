/* Autogenerated file, do not edit! */

/* eslint-disable */
import {
	AztecAddress,
	AztecAddressLike,
	CompleteAddress,
	Contract,
	ContractArtifact,
	ContractBase,
	ContractFunctionInteraction,
	ContractInstanceWithAddress,
	ContractMethod,
	ContractStorageLayout,
	ContractNotes,
	DeployMethod,
	EthAddress,
	EthAddressLike,
	FieldLike,
	Fr,
	FunctionSelectorLike,
	loadContractArtifact,
	NoirCompiledContract,
	Point,
	PublicKey,
	Wallet,
	WrappedFieldLike,
} from "@aztec/aztec.js";
import ECDSASecp256K1ModuleContractArtifactJson from "../../contracts/validators/ecdsa-k256/target/ecdsa_validator-ECDSASecp256K1Module.json" assert { type: "json" };
export const ECDSASecp256K1ModuleContractArtifact = loadContractArtifact(
	ECDSASecp256K1ModuleContractArtifactJson as NoirCompiledContract
);

/**
 * Type-safe interface for contract ECDSASecp256K1Module;
 */
export class ECDSASecp256K1ModuleContract extends ContractBase {
	private constructor(instance: ContractInstanceWithAddress, wallet: Wallet) {
		super(instance, ECDSASecp256K1ModuleContractArtifact, wallet);
	}

	/**
	 * Creates a contract instance.
	 * @param address - The deployed contract's address.
	 * @param wallet - The wallet to use when interacting with the contract.
	 * @returns A promise that resolves to a new Contract instance.
	 */
	public static async at(address: AztecAddress, wallet: Wallet) {
		return Contract.at(
			address,
			ECDSASecp256K1ModuleContract.artifact,
			wallet
		) as Promise<ECDSASecp256K1ModuleContract>;
	}

	/**
	 * Creates a tx to deploy a new instance of this contract.
	 */
	public static deploy(wallet: Wallet) {
		return new DeployMethod<ECDSASecp256K1ModuleContract>(
			Fr.ZERO,
			wallet,
			ECDSASecp256K1ModuleContractArtifact,
			ECDSASecp256K1ModuleContract.at,
			Array.from(arguments).slice(1)
		);
	}

	/**
	 * Creates a tx to deploy a new instance of this contract using the specified public keys hash to derive the address.
	 */
	public static deployWithPublicKeysHash(publicKeysHash: Fr, wallet: Wallet) {
		return new DeployMethod<ECDSASecp256K1ModuleContract>(
			publicKeysHash,
			wallet,
			ECDSASecp256K1ModuleContractArtifact,
			ECDSASecp256K1ModuleContract.at,
			Array.from(arguments).slice(2)
		);
	}

	/**
	 * Creates a tx to deploy a new instance of this contract using the specified constructor method.
	 */
	public static deployWithOpts<
		M extends keyof ECDSASecp256K1ModuleContract["methods"]
	>(
		opts: { publicKeysHash?: Fr; method?: M; wallet: Wallet },
		...args: Parameters<ECDSASecp256K1ModuleContract["methods"][M]>
	) {
		return new DeployMethod<ECDSASecp256K1ModuleContract>(
			opts.publicKeysHash ?? Fr.ZERO,
			opts.wallet,
			ECDSASecp256K1ModuleContractArtifact,
			ECDSASecp256K1ModuleContract.at,
			Array.from(arguments).slice(1),
			opts.method ?? "constructor"
		);
	}

	/**
	 * Returns this contract's artifact.
	 */
	public static get artifact(): ContractArtifact {
		return ECDSASecp256K1ModuleContractArtifact;
	}

	public static get storage(): ContractStorageLayout<"public_keys"> {
		return {
			public_keys: {
				slot: new Fr(1n),
				typ: "Map<AztecAddress, PrivateMutable<EcdsaPublicKeyNote, Context>, Context>",
			},
		} as ContractStorageLayout<"public_keys">;
	}

	public static get notes(): ContractNotes<"EcdsaPublicKeyNote"> {
		return {
			EcdsaPublicKeyNote: {
				id: new Fr(6999100115978011798108105997510112178111116101n),
			},
		} as ContractNotes<"EcdsaPublicKeyNote">;
	}

	/** Type-safe wrappers for the public methods exposed by the contract. */
	//@ts-ignore
	public override methods!: {
		/** install(keys: array) */
		install: ((keys: FieldLike[]) => ContractFunctionInteraction) &
			Pick<ContractMethod, "selector">;

		/** set_new_public_key(pub_key_x: array, pub_key_y: array) */
		set_new_public_key: ((
			pub_key_x: (bigint | number)[],
			pub_key_y: (bigint | number)[]
		) => ContractFunctionInteraction) &
			Pick<ContractMethod, "selector">;

		/** is_installed(account: struct) */
		is_installed: ((account: AztecAddressLike) => ContractFunctionInteraction) &
			Pick<ContractMethod, "selector">;

		/** validate(mode: field, outer_hash: field) */
		validate: ((
			mode: FieldLike,
			outer_hash: FieldLike
		) => ContractFunctionInteraction) &
			Pick<ContractMethod, "selector">;

		/** view_public_keys(account: struct) */
		view_public_keys: ((
			account: AztecAddressLike
		) => ContractFunctionInteraction) &
			Pick<ContractMethod, "selector">;

		/** compute_note_hash_and_nullifier(contract_address: struct, nonce: field, storage_slot: field, note_type_id: field, serialized_note: array) */
		compute_note_hash_and_nullifier: ((
			contract_address: AztecAddressLike,
			nonce: FieldLike,
			storage_slot: FieldLike,
			note_type_id: FieldLike,
			serialized_note: FieldLike[]
		) => ContractFunctionInteraction) &
			Pick<ContractMethod, "selector">;

		/** uninstall() */
		uninstall: (() => ContractFunctionInteraction) &
			Pick<ContractMethod, "selector">;
	};
}
