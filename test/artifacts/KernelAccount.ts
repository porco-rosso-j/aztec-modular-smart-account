/* Autogenerated file, do not edit! */

/* eslint-disable */
import {
	AztecAddress,
	AztecAddressLike,
	CompleteAddress,
	Contract,
	ContractArtifact,
	ContractBase,
	ContractFunctionInteraction,
	ContractInstanceWithAddress,
	ContractMethod,
	ContractStorageLayout,
	ContractNotes,
	DeployMethod,
	EthAddress,
	EthAddressLike,
	FieldLike,
	Fr,
	FunctionSelectorLike,
	loadContractArtifact,
	NoirCompiledContract,
	Point,
	PublicKey,
	Wallet,
	WrappedFieldLike,
} from "@aztec/aztec.js";
import KernelAccountContractArtifactJson from "../../contracts/account/target/kernel_account-KernelAccount.json" assert { type: "json" };
export const KernelAccountContractArtifact = loadContractArtifact(
	KernelAccountContractArtifactJson as NoirCompiledContract
);

/**
 * Type-safe interface for contract KernelAccount;
 */
export class KernelAccountContract extends ContractBase {
	private constructor(instance: ContractInstanceWithAddress, wallet: Wallet) {
		super(instance, KernelAccountContractArtifact, wallet);
	}

	/**
	 * Creates a contract instance.
	 * @param address - The deployed contract's address.
	 * @param wallet - The wallet to use when interacting with the contract.
	 * @returns A promise that resolves to a new Contract instance.
	 */
	public static async at(address: AztecAddress, wallet: Wallet) {
		return Contract.at(
			address,
			KernelAccountContract.artifact,
			wallet
		) as Promise<KernelAccountContract>;
	}

	/**
	 * Creates a tx to deploy a new instance of this contract.
	 */
	public static deploy(
		wallet: Wallet,
		default_validator: AztecAddressLike,
		signing_pubkeys: FieldLike[]
	) {
		return new DeployMethod<KernelAccountContract>(
			Fr.ZERO,
			wallet,
			KernelAccountContractArtifact,
			KernelAccountContract.at,
			Array.from(arguments).slice(1)
		);
	}

	/**
	 * Creates a tx to deploy a new instance of this contract using the specified public keys hash to derive the address.
	 */
	public static deployWithPublicKeysHash(
		publicKeysHash: Fr,
		wallet: Wallet,
		default_validator: AztecAddressLike,
		signing_pubkeys: FieldLike[]
	) {
		return new DeployMethod<KernelAccountContract>(
			publicKeysHash,
			wallet,
			KernelAccountContractArtifact,
			KernelAccountContract.at,
			Array.from(arguments).slice(2)
		);
	}

	/**
	 * Creates a tx to deploy a new instance of this contract using the specified constructor method.
	 */
	public static deployWithOpts<
		M extends keyof KernelAccountContract["methods"]
	>(
		opts: { publicKeysHash?: Fr; method?: M; wallet: Wallet },
		...args: Parameters<KernelAccountContract["methods"][M]>
	) {
		return new DeployMethod<KernelAccountContract>(
			opts.publicKeysHash ?? Fr.ZERO,
			opts.wallet,
			KernelAccountContractArtifact,
			KernelAccountContract.at,
			Array.from(arguments).slice(1),
			opts.method ?? "constructor"
		);
	}

	/**
	 * Returns this contract's artifact.
	 */
	public static get artifact(): ContractArtifact {
		return KernelAccountContractArtifact;
	}

	public static get storage(): ContractStorageLayout<
		"default_validator" | "validators" | "nonce"
	> {
		return {
			default_validator: {
				slot: new Fr(1n),
				typ: "PrivateMutable<AddressNote, Context>",
			},
			validators: {
				slot: new Fr(2n),
				typ: "Map<AztecAddress, PrivateMutable<ValidatorNote, Context>, Context>",
			},
			nonce: {
				slot: new Fr(3n),
				typ: "PrivateMutable<ValueNote, Context>",
			},
		} as ContractStorageLayout<"default_validator" | "validators" | "nonce">;
	}

	public static get notes(): ContractNotes<
		"ValueNote" | "ValidatorNote" | "AddressNote"
	> {
		return {
			ValueNote: {
				id: new Fr(869710811710178111116101n),
			},
			ValidatorNote: {
				id: new Fr(86971081051009711611111478111116101n),
			},
			AddressNote: {
				id: new Fr(6510010011410111511578111116101n),
			},
		} as ContractNotes<"ValueNote" | "ValidatorNote" | "AddressNote">;
	}

	/** Type-safe wrappers for the public methods exposed by the contract. */
	// @ts-ignore
	public override methods!: {
		/** get_nonce() */
		get_nonce: (() => ContractFunctionInteraction) &
			Pick<ContractMethod, "selector">;

		/** spend_public_authwit(inner_hash: field) */
		spend_public_authwit: ((
			inner_hash: FieldLike
		) => ContractFunctionInteraction) &
			Pick<ContractMethod, "selector">;

		/** compute_note_hash_and_nullifier(contract_address: struct, nonce: field, storage_slot: field, note_type_id: field, serialized_note: array) */
		compute_note_hash_and_nullifier: ((
			contract_address: AztecAddressLike,
			nonce: FieldLike,
			storage_slot: FieldLike,
			note_type_id: FieldLike,
			serialized_note: FieldLike[]
		) => ContractFunctionInteraction) &
			Pick<ContractMethod, "selector">;

		/** constructor(default_validator: struct, signing_pubkeys: array) */
		constructor: ((
			default_validator: AztecAddressLike,
			signing_pubkeys: FieldLike[]
		) => ContractFunctionInteraction) &
			Pick<ContractMethod, "selector">;

		/** spend_private_authwit(inner_hash: field) */
		spend_private_authwit: ((
			inner_hash: FieldLike
		) => ContractFunctionInteraction) &
			Pick<ContractMethod, "selector">;

		/** uninstall_validator(validator_address: struct) */
		uninstall_validator: ((
			validator_address: AztecAddressLike
		) => ContractFunctionInteraction) &
			Pick<ContractMethod, "selector">;

		/** install_validator(validator_address: struct, signing_pubkeys: array) */
		install_validator: ((
			validator_address: AztecAddressLike,
			signing_pubkeys: FieldLike[]
		) => ContractFunctionInteraction) &
			Pick<ContractMethod, "selector">;

		/** entrypoint(app_payload: struct, fee_payload: struct) */
		entrypoint: ((
			app_payload: {
				function_calls: {
					args_hash: FieldLike;
					function_selector: FunctionSelectorLike;
					target_address: AztecAddressLike;
					is_public: boolean;
					is_static: boolean;
				}[];
				nonce: FieldLike;
			},
			fee_payload: {
				function_calls: {
					args_hash: FieldLike;
					function_selector: FunctionSelectorLike;
					target_address: AztecAddressLike;
					is_public: boolean;
					is_static: boolean;
				}[];
				nonce: FieldLike;
				is_fee_payer: boolean;
			}
		) => ContractFunctionInteraction) &
			Pick<ContractMethod, "selector">;

		/** is_validator_installed(validator: struct) */
		is_validator_installed: ((
			validator: AztecAddressLike
		) => ContractFunctionInteraction) &
			Pick<ContractMethod, "selector">;
	};
}
