/* Autogenerated file, do not edit! */

/* eslint-disable */
import {
	AztecAddress,
	AztecAddressLike,
	CompleteAddress,
	Contract,
	ContractArtifact,
	ContractBase,
	ContractFunctionInteraction,
	ContractInstanceWithAddress,
	ContractMethod,
	ContractStorageLayout,
	ContractNotes,
	DeployMethod,
	EthAddress,
	EthAddressLike,
	FieldLike,
	Fr,
	FunctionSelectorLike,
	loadContractArtifact,
	NoirCompiledContract,
	Point,
	PublicKey,
	Wallet,
	WrappedFieldLike,
} from "@aztec/aztec.js";
import MultisigSchnorrModuleContractArtifactJson from "../../contracts/validators/multisig-schnorr/target/multisig_schnorr_validator-MultisigSchnorrModule.json" assert { type: "json" };
export const MultisigSchnorrModuleContractArtifact = loadContractArtifact(
	MultisigSchnorrModuleContractArtifactJson as NoirCompiledContract
);

/**
 * Type-safe interface for contract MultisigSchnorrModule;
 */
export class MultisigSchnorrModuleContract extends ContractBase {
	private constructor(instance: ContractInstanceWithAddress, wallet: Wallet) {
		super(instance, MultisigSchnorrModuleContractArtifact, wallet);
	}

	/**
	 * Creates a contract instance.
	 * @param address - The deployed contract's address.
	 * @param wallet - The wallet to use when interacting with the contract.
	 * @returns A promise that resolves to a new Contract instance.
	 */
	public static async at(address: AztecAddress, wallet: Wallet) {
		return Contract.at(
			address,
			MultisigSchnorrModuleContract.artifact,
			wallet
		) as Promise<MultisigSchnorrModuleContract>;
	}

	/**
	 * Creates a tx to deploy a new instance of this contract.
	 */
	public static deploy(wallet: Wallet) {
		return new DeployMethod<MultisigSchnorrModuleContract>(
			Fr.ZERO,
			wallet,
			MultisigSchnorrModuleContractArtifact,
			MultisigSchnorrModuleContract.at,
			Array.from(arguments).slice(1)
		);
	}

	/**
	 * Creates a tx to deploy a new instance of this contract using the specified public keys hash to derive the address.
	 */
	public static deployWithPublicKeysHash(publicKeysHash: Fr, wallet: Wallet) {
		return new DeployMethod<MultisigSchnorrModuleContract>(
			publicKeysHash,
			wallet,
			MultisigSchnorrModuleContractArtifact,
			MultisigSchnorrModuleContract.at,
			Array.from(arguments).slice(2)
		);
	}

	/**
	 * Creates a tx to deploy a new instance of this contract using the specified constructor method.
	 */
	public static deployWithOpts<
		M extends keyof MultisigSchnorrModuleContract["methods"]
	>(
		opts: { publicKeysHash?: Fr; method?: M; wallet: Wallet },
		...args: Parameters<MultisigSchnorrModuleContract["methods"][M]>
	) {
		return new DeployMethod<MultisigSchnorrModuleContract>(
			opts.publicKeysHash ?? Fr.ZERO,
			opts.wallet,
			MultisigSchnorrModuleContractArtifact,
			MultisigSchnorrModuleContract.at,
			Array.from(arguments).slice(1),
			opts.method ?? "constructor"
		);
	}

	/**
	 * Returns this contract's artifact.
	 */
	public static get artifact(): ContractArtifact {
		return MultisigSchnorrModuleContractArtifact;
	}

	public static get storage(): ContractStorageLayout<
		"signer_public_keys" | "multisig_notes"
	> {
		return {
			signer_public_keys: {
				slot: new Fr(1n),
				typ: "Map<AztecAddress, Map<AztecAddress, PrivateMutable<PublicKeyNote, Context>, Context>, Context>",
			},
			multisig_notes: {
				slot: new Fr(2n),
				typ: "Map<AztecAddress, PrivateMutable<MultiSigNote, Context>, Context>",
			},
		} as ContractStorageLayout<"signer_public_keys" | "multisig_notes">;
	}

	public static get notes(): ContractNotes<
		"EcdsaPublicKeyNote" | "PublicKeyNote" | "MultiSigNote"
	> {
		return {
			EcdsaPublicKeyNote: {
				id: new Fr(6999100115978011798108105997510112178111116101n),
			},
			PublicKeyNote: {
				id: new Fr(8011798108105997510112178111116101n),
			},
			MultiSigNote: {
				id: new Fr(771171081161058310510378111116101n),
			},
		} as ContractNotes<"EcdsaPublicKeyNote" | "PublicKeyNote" | "MultiSigNote">;
	}

	/** Type-safe wrappers for the public methods exposed by the contract. */
	// @ts-ignore
	public override methods!: {
		/** is_installed(account: struct) */
		is_installed: ((account: AztecAddressLike) => ContractFunctionInteraction) &
			Pick<ContractMethod, "selector">;

		/** get_threshold(account: struct) */
		get_threshold: ((
			account: AztecAddressLike
		) => ContractFunctionInteraction) &
			Pick<ContractMethod, "selector">;

		/** install(keys: array) */
		install: ((keys: FieldLike[]) => ContractFunctionInteraction) &
			Pick<ContractMethod, "selector">;

		/** get_owners(account: struct) */
		get_owners: ((account: AztecAddressLike) => ContractFunctionInteraction) &
			Pick<ContractMethod, "selector">;

		/** compute_note_hash_and_nullifier(contract_address: struct, nonce: field, storage_slot: field, note_type_id: field, serialized_note: array) */
		compute_note_hash_and_nullifier: ((
			contract_address: AztecAddressLike,
			nonce: FieldLike,
			storage_slot: FieldLike,
			note_type_id: FieldLike,
			serialized_note: FieldLike[]
		) => ContractFunctionInteraction) &
			Pick<ContractMethod, "selector">;

		/** get_multisig_note(account: struct) */
		get_multisig_note: ((
			account: AztecAddressLike
		) => ContractFunctionInteraction) &
			Pick<ContractMethod, "selector">;

		/** uninstall() */
		uninstall: (() => ContractFunctionInteraction) &
			Pick<ContractMethod, "selector">;

		/** set_new_public_key(owner: struct, pub_key_x: field, pub_key_y: field) */
		set_new_public_key: ((
			owner: AztecAddressLike,
			pub_key_x: FieldLike,
			pub_key_y: FieldLike
		) => ContractFunctionInteraction) &
			Pick<ContractMethod, "selector">;

		/** view_public_keys(account: struct, owners: struct) */
		view_public_keys: ((
			account: AztecAddressLike,
			owners: AztecAddressLike
		) => ContractFunctionInteraction) &
			Pick<ContractMethod, "selector">;

		/** validate(mode: field, outer_hash: field) */
		validate: ((
			mode: FieldLike,
			outer_hash: FieldLike
		) => ContractFunctionInteraction) &
			Pick<ContractMethod, "selector">;
	};
}
